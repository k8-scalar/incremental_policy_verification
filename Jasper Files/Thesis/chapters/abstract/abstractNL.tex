%!TeX root=../../main.tex
\chapter{Samenvatting}                                 \label{ch:abstractNL}

cloud-native is de ontwikkeling en implementatie van container-applicaties in cloud-omgevingen in plaats van op on-site infrastructuur, en is een standaard geworden in de industrie dankzij de vele voordelen zoals kost-efficiëntie, schaalbaarheid en automatisering. Doorheen de verschillende lagen van de technologiestapel bestaan er verschillende tools die helpen met cloud native ontwikkeling, zoals  Docker \cite{docker}, Kubernetes \cite{Bernstein2014} en Openstack \cite{Openstack}, die allemaal hun eigen, soms overlappende, functionaliteiten aanbieden. Een belangrijk aspect omtrent de beveiliging van deze cloud infrastructuren is het beheer van netwerkcommunicatieregels tussen component in de technologiestapel. Deze regels voorkomen de verspreiding van malafide aanvallen tussen componenten door de toegestane communicatie met elkaar te beperken. Deze regels mogen echter ook niet te restrictief zijn omdat ze anders de normale werking van de componenten kunnen tegenhouden. Deze balanceer oefening blijkt nog uitdagender wanneer we de dynamische aard van deze container-clusters in acht nemen, zoals het regelmatig aanmaken of verwijderen van containers.
\\[10pt]

In deze masterproef bekijken we Openstack \cite{Openstack} en Kubernetes \cite{Bernstein2014}, twee tools met hun eigen netwerkbeveiligingsfuncties die zich respectievelijk in de cloud- en clusterlaag van de cloud native stack bevinden. Openstack dient voornamelijk om virtuele machines in een cluster te orchestreren en biedt security group rules aan om te specificiëren welke van deze instanties mogen communiceren met elkaar \cite{sgrule}. Kubernetes daarentegen implementeert gecontaineriseerde applicaties bovenop deze OpenStack instanties en biedt network policies aan om communicatie tussen containers te controleren \cite{nps}. Als deze netwerkbeveiligingsregels in de verschillende lagen van de technologiestapel niet goed op elkaar zijn afgestemd, kunnen ze nieuwe aanvalsvectoren introduceren of de correcte werking van clusters tegenwerken. Voor zover wij weten bestaan er geen state-of-the-art onderzoeksoplossingen dat dit probleem oplossen.
\\[10pt]

In deze masterproef presenteren we een conflictdetectie-algoritme om netwerkbeveiligingsregels tussen de cloud- en clusterlaag, met name Kubernetes en Openstack, te verifiëren. Om dit te doen maken we gebruik van de reachabilitymatrix, geïntroduceerd in de publicatie van Kano \cite{kano}. Tegelijkertijd proberen we de tijdprestaties van Kano te verbeteren door een incrementele update methode voor deze reachabilitymatrix te implementeren. Conflict detectie word getriggerd door de cluster continu te monitoren en de events te filteren die de verbindingen tussen containers in de cluster kunnen beïnvloeden. Wanneer zo een event wordt gevonden wordt de incrementele update methode gebruikt om eventuele connectiviteitswijzigingen te vinden, die vervolgens worden vergeleken met een nagebootste cloudlaag van security group rules om nieuw geïntroduceerde conflicten te vinden. We evalueren het voorgestelde algoritme en vergelijken onze incrementele update methode met de bestaande Kano methode. De resultaten laten zien dat onze implementatie sneller blijkt te zijn dan de kano's zodra de cluster een bepaalde grootte heeft behaald, met als nadeel extra geheugenverbruik. Met een maximum gemiddelde van 474ms in de grootste cluster setup van ons experiment bewijst onze conflict detectie methode sneller te zijn dan de gemiddelde cold-start container opstart tijd, terwijl hetslechts een kleine extra tijdskost bovenop de incrementele update methode introduceert.
